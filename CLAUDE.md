- In all interactions and commit messages, be extremely concise and sacrifice grammar for the sake of concision.
- Do not write any code until you're fully ready to implement it.
- It's IMPORTANT for each implementation to begin with writing and reviewing tests BEFORE moving on to implementation (TDD test-driven development).
  Write minimalist tests. Don't overdo it - about three general end-to-end tests per implementation is enough.
- Before writing tests, write a concise implementation plan with numbered steps.
- At the end of each plan, give me a list of unresolved questions to answer, if any.
  Make the questions extremely concise.
  Sacrifice grammar for the sake of concision.
- After implementation, run all tests to ensure nothing is broken.
- After implementation, write concise documentation updates if necessary.
- After implementation, write a concise changelog entry summarizing the changes made.
- After implementation, update the version number according to semantic versioning rules.
- Follow all steps in the implementation plan methodically.
- After implementation, review the entire codebase for any necessary refactoring or cleanup.
- Before each implementation, review `docs/LESSONS_LEARNED.md` for any relevant insights.
- Before each implementation, review `docs/ARCHITECTURE_ANALYSIS.md` for any relevant architectural considerations.
- Before each implementation, review `CLAUDE.md` for any relevant guidelines.
- After each implementation, review `docs/LESSONS_LEARNED.md` to add any new insights gained.
- After each implementation, review `docs/ARCHITECTURE_ANALYSIS.md` to update any architectural considerations.
- After each implementation, review `CLAUDE.md` to update any relevant guidelines.
- Always prioritize code quality and maintainability.
- Commit often, with small and focused commits.
- Write concise commit messages that clearly describe the changes made.
- For simple queries, use under five tool calls, but for more complex queries you can use up to 15 tool calls.
- In Vitest suites, do not reassign imported module exports; use `vi.spyOn(...).mockImplementation(...)`.
- For VS Code mocks, include real API semantics (`thisArg` in command registration, config defaults, `workspace.textDocuments`) when tests hit runtime integration paths.
- For parser tests using `parseXml`, cover both rooted and root-stripped XML shapes.
- In command tests, if stubbing `runByRepository`, pass `Uri[]` to callback; path mapping belongs to `runByRepositoryPaths`.
- For coverage pushes, rank by uncovered lines and execute fail-cluster passes largest bucket first.
- Use SVN canonical auth cache folder naming in code/tests: `auth/svn.simple`.
- In path validation, reject Windows-absolute forms on all platforms (`C:\`, `\\server\share`, `\rooted`).
- For VS Code E2E in CI, keep `.vscode-test.mjs` target list explicit and stable; skip suite early when binaries/commands unavailable.
- In cross-platform unit tests, avoid `startsWith(mockHome)` assertions; assert invariant path suffix + absolute path instead.
- In suites with background polling/watchers, teardown order: dispose repositories, wait briefly, then delete temp repos.
